package models.lotevents

import java.time.ZonedDateTime

import models.TaggedIds._
import models._
import models.lotevents.logic.CommandSource
import play.api.libs.json.JsObject
import tagging._
import NewOps._

/**
  * Parent trait for all lot events for all auction types. For storage, they
  * are wrapped in [[StoredLotEvent]] to carry information about the lot they
  * pertain to, their unique ID and their actual timing within the auction.
  */
sealed trait LotEvent extends Serializable

/** Marker trait for events accepted in a first-price auction. */
sealed trait FirstPriceLotEvent extends LotEvent

/** Marker trait for events accepted in auction. */
sealed trait CompositeLotEvent extends LotEvent

/** Marker trait for events the operator applies. */
sealed trait LiveOperatorEvent extends LotEvent

/** Marker trait for events that can only be generated by the calculators. */
sealed trait GeneratedEvent extends LotEvent

/** Marker trait for bid events */
sealed trait BidPlaced extends LotEvent {
  def amountCents: Long
  def bidder: Bidder
}

case object BiddingOpened extends CompositeLotEvent with FirstPriceLotEvent

case object BiddingClosed
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with LiveOperatorEvent

case class StartingPriceChanged(newStartingPriceCents: Long)
  extends CompositeLotEvent
    with FirstPriceLotEvent {
  require(
    newStartingPriceCents >= 0,
    "StartingPriceChanged.newStartingPriceCents must be > 0"
  )
}

case class ReservePriceChanged(newReserve: Option[Reserve])
  extends CompositeLotEvent
    with FirstPriceLotEvent

case object UnknownReserveMet
  extends CompositeLotEvent
    with FirstPriceLotEvent

case class EstimateChanged(newEstimate: Estimate)
  extends CompositeLotEvent
    with FirstPriceLotEvent

/**
  * Changes the increment going forward in the auction.
  *
  * Normally, we'd use something like `Either` to represent mutually exclusive
  * parameters, but this more directly represents the serialization format.
  */
case class IncrementChanged(incrementStrategy: TemporaryIncrementStrategy)
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with LiveOperatorEvent

/** Switches to a new increment policy going forward. */
case class IncrementPolicyChanged(newIncrementPolicy: IncrementPolicyId)
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with LiveOperatorEvent

/** Switches to a new max bid policy going forward. */
case class MaxBidRuleChanged(newMaxBidRule: MaxBidRule)
  extends CompositeLotEvent
    with FirstPriceLotEvent

/** Switches to a new next increment rule going forward. */
case class NextIncrementRuleChanged(newNextIncrementRule: NextIncrementRule)
  extends CompositeLotEvent
    with FirstPriceLotEvent

/**
  * Since a composite lot can be open for pre-bidding, this acts as the
  * BiddingOpened event for the live bidding phase. BiddingClosed still closes
  * all forms of bidding.
  */
case object CompositeLotPlacedOnBlock
  extends CompositeLotEvent
    with LiveOperatorEvent

/** Sets the opening bid for a live lot. */
case class FloorAskingPriceSet(amountCents: Long)
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with LiveOperatorEvent {
  require(amountCents >= 0, "FloorAskingPriceSet.amountCents must be >= 0")
}

case object FairWarning
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with LiveOperatorEvent

case object FinalCall
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with LiveOperatorEvent

case class LiveOperatorEventUndone(event: LotEvent)
  extends CompositeLotEvent
    with FirstPriceLotEvent

/**
  * Bid with "max bid" semantics: a winning bid has the greatest amount, and
  * the selling price will the second-place bid (plus an amount of up to an
  * increment).
  */
case class SecondPriceBidPlaced(amountCents: Long, bidder: Bidder)
  extends CompositeLotEvent
    with BidPlaced {
  require(amountCents >= 0, "SecondPriceBidPlaced.amountCents must be >= 0")
  require(
    bidder.isInstanceOf[ArtsyBidder],
    "SecondPriceBidPlaced.bidder must be an ArtsyBidder"
  )
}

/**
  * Bid with first-price semantics: a winning bid has the greatest amount, and
  * the selling price will be the amount bid.
  */
case class FirstPriceBidPlaced(amountCents: Long, bidder: Bidder)
  extends CompositeLotEvent
    with FirstPriceLotEvent
    with BidPlaced {
  require(amountCents >= 0, "FirstPriceBidPlaced.amountCents must be >= 0")
}

/**
  * Represents a confirmation from the auctioneer that the highest Artsy
  * bidder is winning. Note that even though multiple bids may contribute to
  * the highest Artsy bid, the winning Artsy bid will always go to the highest
  * Artsy bidder. Also, note that there's no guarantee that the auctioneer's
  * increments match our increment policy. So we confirm Artsy bids at the
  * amount the auctioneer quotes, not at our internal amounts. Our internal
  * auction sets the maximum amount the clerk is authorized to bid in-room.
  */
case class CompositeOnlineBidConfirmed(amountCents: Long)
  extends CompositeLotEvent
    with LiveOperatorEvent {
  require(
    amountCents >= 0,
    "CompositeOnlineBidConfirmed.amountCents must be >= 0"
  )
}

/** Cancels a prior bid */
case class BidCancelled(bid: LotEvent, reason: String)
  extends CompositeLotEvent
    with FirstPriceLotEvent

/**
  * Placeholder reference to another LotEvent for serialization purposes.
  * These are removed and replaced by the actual events they reference.
  *
  * @param eventId the ID of the event being referenced.
  */
// TODO: phase out IdReference as an independent LotEvent type. If it's just a static property, this is much easier.
case class IdReference(eventId: EventId)
  extends LotEvent
    with GeneratedEvent {
  require(eventId.nonEmpty, "IdReference.eventId must not be empty")
}

/**
  * Attributes parts of the AuctionCalculator can store with events to modify
  * behavior further along in the logic or to attach metadata for client
  * consumption. Not every attribute should be visible to public clients, so
  * `isPrivileged` provides a mechanism for filtering out some attributes.
  */
sealed abstract class LotEventAttribute(val isPrivileged: Boolean)
  extends Serializable

object LotEventAttribute {

  /** Marks an event as undone by some other event. */
  case object LotEventUndone extends LotEventAttribute(false)

  /** Attaches a copy of an event referenced by ID in the host event. */
  case class IdReferencedEvent(event: StoredLotEvent)
    extends LotEventAttribute(true)

  /** Connects a virtual event to the real event that caused it. */
  case class OriginatingEvent(event: StoredLotEvent)
    extends LotEventAttribute(true)

  /** Contains client-supplied metadata (e.g. User Agent). */
  case class ClientMetadata(payload: JsObject) extends LotEventAttribute(true)

  /** Contains the credentials an API client persisted an event with. */
  case class ClientCredentials(credentials: UserCredentials)
    extends LotEventAttribute(true)

  /** Contains the credentials an API client persisted an event with. */
  case class ClientCommandSource(source: CommandSource)
    extends LotEventAttribute(true)

  /**
    * Marks an event as ignored for calculation purposes. This is kind of like
    * `LotEventUndone`, but not intended to by client-visible. It currently
    * exists as a workaround for how the live calculators treat BiddingOpened.
    * TODO this can be removed once we fix BiddingOpened handling
    */
  case object IgnoredEvent extends LotEventAttribute(true)

  /** Propagates an event's position in the event history. */
  case class EventIndex(index: Int) extends LotEventAttribute(false)

  case class ExecutedBidIndex(index: Int) extends LotEventAttribute(true)
}

case class StoredLotEvent(
                           event: LotEvent,
                           lotId: LotId,
                           eventId: EventId,
                           createdAt: ZonedDateTime,
                           attributes: Set[LotEventAttribute]
                         ) extends Serializable
  with SoftRequire {
  import LotEventAttribute._

  /**
    * Depending on how we want to portray the events of an auction, we
    * sometimes need to convert from the canonical representation of an event
    * to some other representation.
    */
  def asOtherEvent(other: LotEvent): StoredLotEvent = copy(event = other)

  def withEventId(newEventId: EventId): StoredLotEvent =
    copy(eventId = newEventId)

  def withCreatedAt(newCreatedAt: ZonedDateTime): StoredLotEvent =
    copy(createdAt = newCreatedAt)

  def toStoredBidOpt = this.event match {
    case bid: BidPlaced => Some(StoredBid(bid, this))
    case _              => None
  }

  /** Attach metadata to this event. */
  def addAttribute(newAttribute: LotEventAttribute): StoredLotEvent =
    copy(attributes = attributes + newAttribute)

  def undone   = addAttribute(LotEventUndone)
  def isUndone = attributes.contains(LotEventUndone)

  def ignored   = addAttribute(IgnoredEvent)
  def isIgnored = attributes.contains(IgnoredEvent)

  def withIdReferencedEvent(referencedEvent: StoredLotEvent) =
    addAttribute(IdReferencedEvent(referencedEvent))

  def idReferencedEvent = attributes.collectFirst {
    case IdReferencedEvent(e) => e
  }

  def hasIdReferenceMatching(matcher: PartialFunction[StoredLotEvent, Any]) =
    idReferencedEvent.collectFirst(matcher).nonEmpty

  def withOriginatingEvent(referencedEvent: StoredLotEvent) =
    addAttribute(OriginatingEvent(referencedEvent))

  def withOriginatingEventOpt(referencedEventOpt: Option[StoredLotEvent]) =
    referencedEventOpt match {
      case Some(referencedEvent) => withOriginatingEvent(referencedEvent)
      case _                     => this
    }

  def originatingEvent = attributes.collectFirst {
    case OriginatingEvent(referencedEvent) => referencedEvent
  }

  def withIndex(index: Int) =
    copy(attributes = attributes.filterNot(_.isInstanceOf[EventIndex]))
      .addAttribute(EventIndex(index))

  def index = {
    softRequire(
      attributes.exists(_.isInstanceOf[EventIndex]),
      s"$this is missing an `index` attribute, which should be present if events have been preprocessed."
    )
    attributes.collectFirst { case EventIndex(index) => index }.getOrElse(0)
  }

  def executedBidIndexOpt = attributes.collectFirst {
    case ExecutedBidIndex(i) => i
  }

  def withExecutedBidIndex(index: Int) =
    copy(attributes = attributes.filterNot(_.isInstanceOf[ExecutedBidIndex]))
      .addAttribute(ExecutedBidIndex(index))

  def publicForm = copy(attributes = attributes.filterNot(_.isPrivileged))

  // same as publicForm now
  def externalOperatorForm = publicForm

  /**
    * Used to create unique IDs for events that may be duplicated within a
    * view of an auction's events.
    */
  def withIdSuffix(suffix: String): StoredLotEvent = {
    val eventIdWithSuffix = s"$eventId-$suffix".taggedWith[EventIdTag]
    copy(eventId = eventIdWithSuffix)
  }

  def sourceOpt: Option[CommandSource] = attributes.collectFirst {
    case ClientCommandSource(source) => source
  }
}


sealed trait ValidationResult {
  def withMeta(meta: LotEventValidationMeta): ValidationResult
}

case class ValidationSuccessful(
                                 meta: LotEventValidationMeta = LotEventValidationMeta.empty
                               ) extends ValidationResult {
  def withMeta(meta: LotEventValidationMeta) = copy(meta = meta)
}

case class ValidationFailed(
                             reason: RejectionReason,
                             meta: LotEventValidationMeta = LotEventValidationMeta.empty
                           ) extends ValidationResult {
  def withMeta(meta: LotEventValidationMeta) = copy(meta = meta)
}

/**
  * Reasons events might be rejected. Remember to add any new RejectionReason
  * subtypes to the `RejectionReason.allReasons` list.
  */
sealed trait RejectionReason
case object TimeoutReason                         extends RejectionReason
case object BidAmountTooLow                       extends RejectionReason
case object BidToBeCancelledNonexistent           extends RejectionReason
case object BiddingAlreadyOpened                  extends RejectionReason
case object EventCannotBeInput                    extends RejectionReason
case object EventIncompatibleWithAuctionType      extends RejectionReason
case object EventOnlyAppliesToForSaleLots         extends RejectionReason
case object EventOnlyAppliesToOpenLots            extends RejectionReason
case object FloorBidAmountTooLow                  extends RejectionReason
case object IncrementChangeAfterLotCompleted      extends RejectionReason
case object IncrementPolicyDoesNotExist           extends RejectionReason
case object LotAlreadyHasBid                      extends RejectionReason
case object LotAlreadyOnBlock                     extends RejectionReason
case object LotAlreadySellingToBidder             extends RejectionReason
case object LotMustBeOnBlockForFloorBids          extends RejectionReason
case object NoArtsyBidForConfirmationAmount       extends RejectionReason
case object ReserveAlreadyMet                     extends RejectionReason
case object ReservePriceChangeAfterLotIsSelling   extends RejectionReason
case object SecondPriceBidsRequireArtsyBidder     extends RejectionReason
case object StartingPriceChangeAfterBids          extends RejectionReason
case object UndoableLiveOperatorEventNotFound     extends RejectionReason
case object UnknownReserveMetForLotWithoutReserve extends RejectionReason
case object WinningBidCanOnlyBeIncreased          extends RejectionReason

object RejectionReason extends SoftRequire {

  val allReasons = Seq(
    TimeoutReason,
    BidAmountTooLow,
    BidToBeCancelledNonexistent,
    BiddingAlreadyOpened,
    EventCannotBeInput,
    EventIncompatibleWithAuctionType,
    EventOnlyAppliesToForSaleLots,
    EventOnlyAppliesToOpenLots,
    FloorBidAmountTooLow,
    IncrementPolicyDoesNotExist,
    LotAlreadyOnBlock,
    LotAlreadySellingToBidder,
    LotMustBeOnBlockForFloorBids,
    NoArtsyBidForConfirmationAmount,
    ReserveAlreadyMet,
    ReservePriceChangeAfterLotIsSelling,
    SecondPriceBidsRequireArtsyBidder,
    StartingPriceChangeAfterBids,
    UndoableLiveOperatorEventNotFound,
    UnknownReserveMetForLotWithoutReserve,
    WinningBidCanOnlyBeIncreased
  )

  def fromName(name: String): Option[RejectionReason] = {
    allReasons.find(_.toString == name).tee { reasonOpt =>
      softRequire(reasonOpt.nonEmpty, s"Unrecognized rejection reason: $name")
    }
  }
}

/**
  * This is a convenience class that allows us to repackage BidPlaced events
  * in a type-safe way, so that we can access their bid properties, their
  * StoredLotEvent metadata, and compare them.
  *
  * An alternative would be to have StoredLotEvent take a covariant type
  * parameter for what type of LotEvent it stores, but that seems more
  * complex.
  *
  * @param bid the BidPlaced event.
  * @param storedEvent the original StoredLotEvent.
  * @param precedingBidOpt an overridden index for letting a winning bid
  *                        increase inherit the precedence of the original
  *                        bid.
  * @param confirmedAmountCentsOpt the amount an online bid was confirmed at.
  */
case class StoredBid(
                      bid: BidPlaced,
                      storedEvent: StoredLotEvent,
                      precedingBidOpt: Option[StoredBid] = None,
                      confirmedAmountCentsOpt: Option[Long] = None
                    ) extends SoftRequire {
  val amountCents = bid.amountCents
  val bidder      = bid.bidder

  softRequire(
    storedEvent.event == bid,
    s"StoredBid should only be constructed with the same bid ($bid) that is contained in the storedEvent (${pprint
      .apply(storedEvent)}). Please debug this lot."
  )
  softRequire(
    precedingBidOpt.forall(_.bidder == bidder),
    s"A bid can only have a bid by the same bidder as a preceding bid. this:$this, precedingBid:$precedingBidOpt"
  )

  // TODO: This softRequire is commented out because it currently breaks when
  // we calculate activeStoredBids for the live event view. It would be nice
  // to resolve this.
  //softRequire(confirmedAmountCentsOpt.forall(
  // _ <= amountCents),
  // s"The confirmation amount ($confirmedAmountCentsOpt) must not be greater than the bid amount ($amountCents)"
  // )

  val index: Int    = precedingBidOpt.map(_.index).getOrElse(storedEvent.index)
  def isFirstPrice  = bid.isInstanceOf[FirstPriceBidPlaced]
  def isSecondPrice = bid.isInstanceOf[SecondPriceBidPlaced]

  def increaseFrom(otherBid: StoredBid) =
    copy(precedingBidOpt = Some(otherBid))

  def confirmAt(amountCents: Long) =
    copy(confirmedAmountCentsOpt = Some(amountCents))
}

sealed trait BiddingStatus

object BiddingStatus {
  case object Upcoming extends BiddingStatus
  case object Open     extends BiddingStatus
  case object OnBlock  extends BiddingStatus // Only for live auctions
  case object Complete extends BiddingStatus
}

sealed trait ReserveStatus

object ReserveStatus {
  case object NoReserve     extends ReserveStatus
  case object ReserveNotMet extends ReserveStatus
  case object ReserveMet    extends ReserveStatus
}

sealed trait SoldStatus

object SoldStatus {
  case object ForSale extends SoldStatus
  case object Sold    extends SoldStatus
  case object Passed  extends SoldStatus
}

// There is actually one more dimension of the status of a lot, which is
// its position within its sale. But this exists out of the modeling of
// the lot itself.

/**
  * Contains data we want to capture during validation of a new event from
  * before the prospective event is persisted. This allows the logic after
  * persistence to react to the change that occurred, rather than just the
  * instantaneous new state.
  * @param prevMaxBidEventIdOpt the prior max bid.
  */
case class LotEventValidationMeta(prevMaxBidEventIdOpt: Option[EventId])

object LotEventValidationMeta {
  val empty = LotEventValidationMeta(None)
}

//
// Extractors for matching event types.
//

object ArtsyBidPlaced {

  /** Matches BidPlaced events by Artsy bidders */
  def unapply(arg: LotEvent): Option[(BidPlaced, ArtsyBidder)] = arg match {
    case bid: BidPlaced =>
      bid.bidder match {
        case bidder: ArtsyBidder => Some((bid, bidder))
        case _                   => None
      }
    case _ => None
  }
}

object OfflineBidPlaced {

  /** Matches BidPlaced events by offline bidders */
  def unapply(arg: LotEvent): Option[BidPlaced] = arg match {
    case bid: BidPlaced if bid.bidder == OfflineBidder => Some(bid)
    case _                                             => None
  }
}

object LiveOperatorEvent {

  /** Matches events corresponding to operator commands. */
  def unapply(arg: LotEvent): Option[LotEvent] = arg match {
    case _: LiveOperatorEvent | OfflineBidPlaced(_) => Some(arg)
    case _                                          => None
  }

  def matches(event: LotEvent) = event match {
    case LiveOperatorEvent(_) => true
    case _                    => false
  }
}

object OpenLotEvent {

  /** Matches events allowed for open lots. */
  def unapply(arg: LotEvent): Option[LotEvent] = arg match {
    case _: BidPlaced | BiddingClosed | CompositeLotPlacedOnBlock |
         FairWarning | FinalCall | _: CompositeOnlineBidConfirmed =>
      Some(arg)

    case _ =>
      None
  }
}

object ForSaleLotEvent {

  /** Matches events allowed for lots that have not yet ended. */
  def unapply(arg: LotEvent): Option[LotEvent] = arg match {
    case _: IncrementChanged | _: IncrementPolicyChanged |
         UnknownReserveMet =>
      Some(arg)
    case _ =>
      None
  }
}

object StoredEvent {

  /** Shorthand for extracting just the event from a StoredLotEvent. */
  def unapply(arg: StoredLotEvent): Option[LotEvent] = Some(arg.event)
}

object StoredLiveOperatorEventUndone {

  def unapply(arg: StoredLotEvent): Option[StoredLotEvent] = arg match {
    case e @ StoredEvent(_: LiveOperatorEventUndone) => e.idReferencedEvent
    case _                                           => None
  }
}

object StoredLiveOperatorEventById {

  /**
    * If the matched StoredLotEvent contains an undoable event that hasn't yet
    * been undone, this extracts the event ID of that event.
    */
  def unapply(arg: StoredLotEvent): Option[EventId] = arg match {
    case s @ StoredLotEvent(LiveOperatorEvent(_), _, eventId, _, _)
      if !s.isUndone =>
      Some(eventId)
    case _ => None
  }
}

object BidCancelledEventId {

  def unapply(arg: LotEvent): Option[EventId] = arg match {
    case BidCancelled(IdReference(eventId), _) => Some(eventId)
    case _                                     => None
  }
}

object LiveOperatorUndoneEventId {

  def unapply(arg: LotEvent): Option[EventId] = arg match {
    case LiveOperatorEventUndone(IdReference(eventId)) => Some(eventId)
    case _                                             => None
  }
}


object LotEvent {
  /** Events wrapped in their StoredLotEvent containers. */
  type PastEvents = Seq[StoredLotEvent]

  implicit class PublicLotHistory(val privilegedLotHistory: PastEvents)
    extends AnyVal {
    def publicForm = privilegedLotHistory.map(_.publicForm)
  }

  implicit class ExternalOperatorLotHistory(
                                             val privilegedLotHistory: PastEvents
                                           ) extends AnyVal {
    def externalOperatorForm = privilegedLotHistory.map(_.externalOperatorForm)
  }
}